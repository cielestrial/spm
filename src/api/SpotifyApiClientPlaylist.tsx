import axios from "axios";
import { getLimit, server, duplicateManager } from "./ApiClientData";
import { generatePlaylistKey } from "./functions/HelperFunctions";
import { useSpotifyQuery } from "./QueryApi";
import { rateLimitSpotify } from "./SpotifyApiClientSide";
import {
  optionsType,
  playlistsType,
  playlistType,
  tracksType,
} from "./SpotifyApiClientTypes";

const options: optionsType = { offset: 0, limit: 0 };

/**
 * Get a user's playlists
 * @returns
 */
export const getPlaylists = async (
  playlists: React.MutableRefObject<playlistsType>
) => {
  if (
    playlists.current !== undefined &&
    playlists.current.total === playlists.current.list.size
  ) {
    console.log("Playlists retrieved from client");
    return playlists.current;
  }
  let newOffset: Promise<number> | number = 0;
  options.offset = 0;
  options.limit = getLimit;
  try {
    const res = await axios.post(server + "/playlists", {
      options,
    });
    await rateLimitSpotify(res);
    playlists.current = {
      total: res.data.total,
      list: new Map<string, playlistType>(
        res.data.list.map((playlist: playlistType) => [
          generatePlaylistKey(playlist),
          playlist,
        ])
      ),
    };
    newOffset = (newOffset as number) + getLimit;
  } catch (err) {
    console.error("Something went wrong with getPlaylists()\n", err);
  }
  if (playlists.current !== undefined) {
    while (0 < newOffset && newOffset < playlists.current.total) {
      console.log("happening");
      newOffset = await appendPlaylists(playlists, newOffset);
    }
    console.log("Playlists retrieved from server");
    return playlists.current;
  } else {
    throw new Error("Failed to retrieve playlists");
  }
};

/**
 * Append remaining playlists
 * @returns
 */
const appendPlaylists = async (
  playlists: React.MutableRefObject<playlistsType>,
  newOffset: Promise<number> | number
) => {
  options.offset = newOffset;
  try {
    const res = await axios.post(server + "/playlists", {
      options,
    });
    await rateLimitSpotify(res);
    for (const playlist of res.data.list)
      playlists.current?.list.set(generatePlaylistKey(playlist), playlist);
    newOffset = (newOffset as number) + getLimit;
  } catch (err) {
    console.error("Something went wrong with appendPlaylists()\n", err);
  }
  return newOffset;
};

/**
 * Playlist exists check
 * @param name
 * @returns
 */
const checkIfPlaylistExists = (
  playlists: React.MutableRefObject<playlistsType>,
  name: string | undefined
) => {
  if (playlists.current === undefined) return undefined;
  let playlist: playlistType | undefined = undefined;
  for (const pl of playlists.current.list.values()) {
    if (
      name?.localeCompare(pl.name, undefined, {
        sensitivity: "accent",
        ignorePunctuation: true,
      }) === 0
    ) {
      playlist = pl;
      break;
    }
  }
  return playlist;
};

/**
 * Create a playlist
 * @param name
 * @returns
 */
export const createPlaylist = async (
  playlists: React.MutableRefObject<playlistsType>,
  name: string | undefined
) => {
  if (name === "" || name === undefined)
    throw new Error("Invalid playlist name");

  let playlist: playlistType | undefined = checkIfPlaylistExists(
    playlists,
    name
  );
  if (playlist !== undefined) {
    console.log("Playlist", name, "already exists");
    return playlist;
  }
  try {
    const res = await axios.post(server + "/create", {
      name,
      description: "Generated by YSPM.",
    });
    await rateLimitSpotify(res);
    playlist = {
      id: res.data.id,
      name: res.data.name,
      uri: res.data.uri,
      owner: res.data.owner,
      snapshot: res.data.snapshot,
      total: res.data.total,
      tracks: [],
      genres: new Map<string, number>(),
      topGenres: [],
      genreSubscriptions: [],
      playlistSubscriptions: new Map<string, playlistType>(),
    };
    if (playlists.current === undefined) {
      playlists.current = {
        total: 0,
        list: new Map<string, playlistType>(),
      };
      playlists.current.list.set(generatePlaylistKey(playlist), playlist);
    } else
      playlists.current.list = new Map<string, playlistType>([
        [generatePlaylistKey(playlist), playlist],
        ...playlists.current.list,
      ]);
    playlists.current.total++;
  } catch (err) {
    console.error("Something went wrong with createPlaylist()\n", err);
  }
  return playlist;
};

/**
 * Follow a playlist
 * @returns
 */
export const followPlaylist = async (
  playlists: React.MutableRefObject<playlistsType>,
  playlist: playlistType | undefined
) => {
  if (playlist === undefined) throw new Error("Playlist  undefined");
  const playlistId = playlist.id;
  try {
    const res = await axios.post(server + "/follow", { playlistId });
    await rateLimitSpotify(res);
    if (playlists.current !== undefined) playlists.current.total++;
  } catch (err) {
    console.error("Something went wrong with followPlaylist()\n", err);
    return false;
  }
  return true;
};

/**
 * Unfollow a playlist
 * @returns
 */
export const unfollowPlaylist = async (
  playlists: React.MutableRefObject<playlistsType>,
  playlist: playlistType | undefined
) => {
  if (playlist === undefined) throw new Error("Playlist undefined");
  let status = false;
  const playlistId = playlist.id;
  try {
    const res = await axios.post(server + "/unfollow", { playlistId });
    await rateLimitSpotify(res);
    if (playlists.current !== undefined) {
      status = playlists.current.list.delete(generatePlaylistKey(playlist));
      if (status) playlists.current.total--;
    }
  } catch (err) {
    console.error("Something went wrong with unfollowPlaylist()\n", err);
    return false;
  }
  return status;
};

export const getTopPlaylistGenres = (
  playlists: React.MutableRefObject<playlistsType>
) => {
  if (playlists.current === undefined) return;
  const top_x = 3;
  let minOccurance = 2;
  for (const playlist of playlists.current.list.values()) {
    if (playlist.genres !== undefined && playlist.genres.size > 0) {
      minOccurance = Math.round(playlist.total * (0.5 / 3));
      playlist.topGenres = Array.from(playlist.genres.entries())
        .filter((value) => value[1] >= minOccurance)
        .sort((a, b) => b[1] - a[1])
        .slice(0, top_x)
        .map((value) => value[0]);
    }
  }
};

/**
 * Add playlist subscriptions
 */
export const addPlaylistSubscriptions = async (
  playlists: React.MutableRefObject<playlistsType>,
  username: string
) => {
  if (playlists.current === undefined) return false;
  let status = true;
  let tempPlaylist: playlistType;
  try {
    const addPlaylistToPlaylist = (await import("./SpotifyApiClientTrack"))
      .addPlaylistToPlaylist;
    for (const target of playlists.current.list.values()) {
      if (target.playlistSubscriptions !== undefined) {
        tempPlaylist = {} as playlistType;
        tempPlaylist.total = 0;
        tempPlaylist.tracks = [];
        for (const playlistSub of target.playlistSubscriptions.values()) {
          tempPlaylist.total += playlistSub.total;
          tempPlaylist.tracks.push(...playlistSub.tracks);
        }
        await useSpotifyQuery(
          addPlaylistToPlaylist,
          0,
          tempPlaylist,
          target,
          username
        );
      }
    }
  } catch (err) {
    console.error(
      "Something went wrong with addPlaylistSubscriptions()\n",
      err
    );
    status = false;
  }
  return status;
};

/**
 * Add genre subscriptions
 */
export const addGenreSubscriptions = async (
  playlists: React.MutableRefObject<playlistsType>,
  username: string
) => {
  if (playlists.current === undefined) return false;
  if (duplicateManager.size === 0) {
    console.log("Empty duplicate manager");
    return true;
  }
  let status = true;
  let tempPlaylist: playlistType;
  try {
    const addPlaylistToPlaylist = (await import("./SpotifyApiClientTrack"))
      .addPlaylistToPlaylist;
    for (const target of playlists.current.list.values()) {
      if (target.genreSubscriptions !== undefined) {
        const allTracks: tracksType[] = [];
        for (const genreSub of target.genreSubscriptions) {
          for (const uniqueTrack of duplicateManager.values()) {
            if (uniqueTrack.track.genres.has(genreSub))
              allTracks.push(uniqueTrack.track);
          }
        }
        tempPlaylist = {} as playlistType;
        tempPlaylist.total = allTracks.length;
        tempPlaylist.tracks = allTracks;
        await useSpotifyQuery(
          addPlaylistToPlaylist,
          0,
          tempPlaylist,
          target,
          username
        );
      }
    }
  } catch (err) {
    console.error("Something went wrong with addGenreSubscriptions()\n", err);
    status = false;
  }
  return status;
};
